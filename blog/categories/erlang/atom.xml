<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: erlang | No Fucking Idea]]></title>
  <link href="http://JakubOboza.github.com/blog/categories/erlang/atom.xml" rel="self"/>
  <link href="http://JakubOboza.github.com/"/>
  <updated>2012-12-17T22:17:26+00:00</updated>
  <id>http://JakubOboza.github.com/</id>
  <author>
    <name><![CDATA[Jakub Oboza]]></name>
    <email><![CDATA[jakub.oboza@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Erlang: digraph]]></title>
    <link href="http://JakubOboza.github.com/blog/2012/11/20/erlang-digraph/"/>
    <updated>2012-11-20T19:20:00+00:00</updated>
    <id>http://JakubOboza.github.com/blog/2012/11/20/erlang-digraph</id>
    <content type="html"><![CDATA[<ul>
<li>This is more "note to self" type of post rather than tutorial thing.</li>
<li>It's hard to write blog posts when you are trying to take over the world :)</li>
</ul>


<h1>Why ?</h1>

<p>Recently in "professor Toons" :)  computer club was a task that was ideal to solve as graph. It was one of this "find path" tasks. Yesterday just before going to bed I thought "Why not solve it in Erlang".  And this are my thoughts about erlang digraph: library.</p>

<h2>Task</h2>

<p>First of all <a href="http://erldocs.com/">http://erldocs.com/</a> is the way to go when working with documentation.</p>

<p>Second "the Task". It had two parts, first was to load xml file with songs and second was to build graph and find playlist between two songs having in mind that for each song following has to start with the same letter that first ended.</p>

<p>example.</p>

<p>if you have song list:
ABC
CBA
BAC
ACB
BBA</p>

<p>And you want to find playlist from ABC to BAC you will get ABC -> CBA -> ACB -> BAC. Easy</p>

<h2>Digraph</h2>

<p>Digraph API is quite nice but there are few things you have to have in mind.</p>

<ul>
<li>Digraph is imperative graph!</li>
<li>You need to pass vertices to get_path!</li>
<li>Graph with loads of edges can be quite big :D</li>
</ul>


<p>To create empty graph you call :new/0</p>

<p><code>erlang
Graph = digraph:new().
</code></p>

<p>To add node to graph you call :add_vertex/2</p>

<p><code>erlang
Data = {Value1, Value2, Value3},
digraph:add_vertex(Graph, Data).
</code></p>

<p>To add edge to graph you call :add_edge/3</p>

<p><code>erlang
digraph:add_edge(Graph, VertexStart, VertexEnd).
</code></p>

<p>To get all vertices from graph (random order) :vertices/1
<code>erlang
Vertices = digraph:vertices(Graph).
</code></p>

<p>And finally to get path you just call :get_path/3</p>

<p><code>erlang
Path = digraph:get_path(Graph, VertexStart, VertexEnd).
</code></p>

<p>This path is a list of vertices in order.  This API is just to remind me essential things about using the digraph from erlang stdlib. This graph is quite simple.</p>

<p>And for me for about 5000 vertices and a lot of edges it consumed 1.5 GB of ram. But when it was created it was super fast to use.</p>

<p>It was fun to play with.</p>

<h2>Quick summary</h2>

<p>I will make quick summary in form of short code sample!</p>

<p>``` erlang
G = digraph:new(),
V1 = digraph:add_vertex(G, "Andrychow"),
V2 = digraph:add_vertex(G, "Krakow"),
V3 = digraph:add_vertex(G, "London"),
V4 = digraph:add_vertex(G, "Warsaw"),
V5 = digraph:add_vertex(G, "Paris"),</p>

<p>digraph:add_edge(G, V1, V2),
digraph:add_edge(G, V2, V4),
digraph:add_edge(G, V2, V5),
digraph:add_edge(G, V2, V3),
digraph:add_edge(G, V3, V4),
digraph:add_edge(G, V3, V2),
digraph:add_edge(G, V2, V1),</p>

<p>PathHome = digraph:get_path(G, V3, V1).
<code>``
This gives you back</code>["London","Krakow","Andrychow"]` so Win! we are at home!</p>

<h1>Summary</h1>

<p>It was fun to play a bit with digraph before going to bed. There is a tone of things i did not use and also look into digraph_utils for even more things :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebar templates]]></title>
    <link href="http://JakubOboza.github.com/blog/2012/05/29/rebar-templates/"/>
    <updated>2012-05-29T21:38:00+01:00</updated>
    <id>http://JakubOboza.github.com/blog/2012/05/29/rebar-templates</id>
    <content type="html"><![CDATA[<p>First question when i need to add new blog to my code I ask is, do i remember all the boilerplate and how many times i will make a mistake this time. No more :). Rebar has a nice thing built in it is templating language that lets us build our own templates.</p>

<h1>Custom template ?</h1>

<p>I always end up looking at old projects and copying parts like <code>gen_server</code> and reusing them. I always knew rebar has option to write them but never had time to look at it. Today lol, i wanted to do some cleaning at home so every thing seems to be a good excuse to not do any cleaning :D.</p>

<h2>What i need to know</h2>

<p>Basic template is made from one or many <code>.erl</code> files written with <code>mustache</code> style <code>{ { } }</code> code and <code>.template</code> file describing what to do with files.</p>

<h2>Let's build gen_server template</h2>

<p>So my first file will be <code>gen_server.erl</code>
``` bash gen_server.erl
%%% @author  { {author_name } } &lt;{ {author_email} }>
%%% @copyright  { {copyright_year } }  { {author_name} }.
%%% @doc  { {description } }</p>

<p>-module( { {name } }).
-behaviour(gen_server).</p>

<p>-author(' { {author_name } } &lt;{ {author_email } }>').</p>

<p>-export([start_link/1]).
-export([init/1, handle_call/3, handle_cast/2, terminate/2, handle_info/2, code_change/3, stop/1]).</p>

<p>% public api</p>

<p>start_link(_Args) ->
  gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).</p>

<p>% state should be change with State that you will pass
init([]) ->
  {ok, state}.</p>

<p>stop(_Pid) ->
  stop().</p>

<p>stop() ->
  gen_server:cast(?MODULE, stop).</p>

<p>handle_call({method_name_and_params}, _From, State) ->
  Response = ok,
  {reply, Response, State};</p>

<p>handle_call(<em>Message, </em>From, State) ->
  {reply, error, State}.</p>

<p>handle_cast(<em>Message, State) -> {noreply, State}.
handle_info(</em>Message, State) -> {noreply, State}.
terminate(<em>Reason, </em>State) -> ok.
code_change(<em>OldVersion, State, </em>Extra) -> {ok, State}.
<code>``
This is the template, i know a bit long i tried to cut out all comments, euint etc and narrow it to minimum. I posted it to show how much you can save :). Now you will need the</code>transformation file`. All this things in { { something } } will be replaced by things we will type in command line or defaults from template file.</p>

<p><code>bash gen_server.template
{variables, [
  {name, "template"},
  {copyright_year, "2012"},
  {author_name, "jakub Oboza"},
  {author_email, "jakub.oboza@gmail.com"}
]}.
{template, "gen_server.erl", "src/{ {name} }.erl"}.
</code>
For me it looks like this, we have few default definitions and at the bottom. template! This is important part it says which file he has to copy where and what will be the name of new file. Now everything should be clear!</p>

<h2>Injet it into rebar!</h2>

<p>All you need now to do is symlink your template folders to <code>~/.rebar/templates</code> and you can use them!
(you can symlink your folder or just create one there :) )</p>

<h2>Use!</h2>

<p><code>bash
Î» rebar create template=gen_server name=example
==&gt; tmp (create)
Writing src/example.erl
</code>
Viola!</p>

<h1>important</h1>

<p>When i was looking at this post i saw that {{ is converted in a wrong way by octopress so i added spaces between them! check repo for correct code!</p>

<h1>My own templates</h1>

<p>Today i started adding my own templates initially i have only <code>gen_server</code> and <code>webmachine_resource</code> but i will add more :). It is fun it is like building your own anti-boiler plate framework.</p>

<p>My templates repo: <a href="https://github.com/JakubOboza/rebar-templates">https://github.com/JakubOboza/rebar-templates</a></p>

<p>Hope this helps!
Cheers!</p>
]]></content>
  </entry>
  
</feed>
