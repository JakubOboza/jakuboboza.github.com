<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | No F*cking Idea]]></title>
  <link href="http://no-fucking-idea.com/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://no-fucking-idea.com/"/>
  <updated>2013-11-20T12:32:53+00:00</updated>
  <id>http://no-fucking-idea.com/</id>
  <author>
    <name><![CDATA[Jakub Oboza]]></name>
    <email><![CDATA[jakub.oboza@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA['if' the real game changer]]></title>
    <link href="http://no-fucking-idea.com/blog/2013/02/21/if-the-real-game-changer/"/>
    <updated>2013-02-21T21:35:00+00:00</updated>
    <id>http://no-fucking-idea.com/blog/2013/02/21/if-the-real-game-changer</id>
    <content type="html"><![CDATA[<p>Recently i was working on a project that is processing campaigns. I asked my self if I can improve it a bit, but not by refactoring existing code but by trying to approach it from a different angle.</p>

<h1>Observations</h1>

<p>I started making mind notes of things that i understand about system i&rsquo;m working with. I never had time to think about grammar of this and really get into it. The system has many parts but i thought it can be reproduced in for of language that is easy to parse and nice to work with. I think i might change my current solution into more LISP looking thing just to make it easier to parse.</p>

<h2>Observation 1</h2>

<p>Each campaign is a sequence of actions that happens one after another. So my initial thought was &ldquo;this is simple&rdquo;. We can represent it by list of actions like this</p>

<p>``` bash</p>

<p> [step] &ndash;> [step] &ndash;> [step]</p>

<p>```</p>

<p>But this is true only for simple campaigns and most of them are NOT like this :(</p>

<h2>Observation 2</h2>

<p>Most of the campaigns are built around key thing. This thing is making decisions! So if i can incorporate &ldquo;if&rdquo; i WIN !
Lets have a look</p>

<p>``` bash</p>

<pre><code>                     /&gt; [step]
                   (No)
                    |
</code></pre>

<p>  [step] &ndash;> [if a &lt; 5] &ndash; ( yes ) &ndash;> [step]</p>

<p>```</p>

<p>Yes! This was it, i think this is solution to all problems, ability to represent campaign as a sequence of steps mixed with if statements essentially abstract syntax tree of campaign.</p>

<h2>Observation 3</h2>

<p>It is not a tree&hellip;its more a graph. But AST will make it :] it is a programming language! So this was in my head and i did not had time to work on it&hellip; but today i decided to give a try and I made first impression of AST that we would need to have to make it work.</p>

<h1>AST</h1>

<p>I wrote simple grammar and made a parser of a very simple &ldquo;ify&rdquo; language. My language starts like this&hellip;</p>

<p><code>bash
-- Grammar
-- x is variable
-- a is artmetic thing aka number
-- n is actual number eg. 1
-- b is boolean
-- opa is arthmetic operator
-- opb is boolean operator
-- opr is comparison operator
-- S is statement
--  a   ::= x | n | - a | a opa a
--  b   ::= true | false | not b | b opb b | a opr a
--  opa ::= + | - | * | /
--  opb ::= and | or
--  opr ::= &gt; | &lt;
--  S   ::= x | x &lt;- a | S1; S2 | ( S ) | if b then S1 else S2
</code></p>

<p>This shows that the grammar is very simple, we can have assigments, operators to test and compare and ofc IF statement ;) this is our key to divnity!</p>

<p>Parser looks kinda ugly because i used parts of the code i wrote before and had i in different projects.</p>

<p>``` haskell
import System.Environment(getArgs)
import System.IO
import Control.Monad
import Text.ParserCombinators.Parsec
import Text.ParserCombinators.Parsec.Expr
import Text.ParserCombinators.Parsec.Language
import qualified Text.ParserCombinators.Parsec.Token as Token</p>

<p>&mdash;  Grammar
&mdash; x is variable
&mdash; a is artmetic thing aka number
&mdash; n is actual number eg. 1
&mdash; b is boolean
&mdash; opa is arthmetic operator
&mdash; opb is boolean operator
&mdash; opr is comparison operator
&mdash; S is statement
&mdash;  a   ::= x | n | &ndash; a | a opa a
&mdash;  b   ::= true | false | not b | b opb b | a opr a
&mdash;  opa ::= + | &ndash; | * | /
&mdash;  opb ::= and | or
&mdash;  opr ::= > | &lt;
&mdash;  S   ::= x | x &lt;&ndash; a | S1; S2 | ( S ) | if b then S1 else S2</p>

<p>data AExpr = Var String</p>

<pre><code>        | IntConst Integer
        | Neg AExpr
        | ABinary ABinOp AExpr AExpr
          deriving (Show)
</code></pre>

<p>data BExpr = BoolConst Bool</p>

<pre><code>        | Not BExpr
        | BBinary BBinOp BExpr BExpr
        | RBinary RBinOp AExpr AExpr
         deriving (Show)
</code></pre>

<p>data ABinOp = Add</p>

<pre><code>        | Subtract
        | Multiply
        | Divide
          deriving (Show)
</code></pre>

<p>data BBinOp = And | Or deriving (Show)
data RBinOp = Greater | Less deriving (Show)</p>

<p>data Stmt = Seq [Stmt]</p>

<pre><code>       | Assign String AExpr
       | If BExpr Stmt Stmt
       | Ident String
         deriving (Show)
</code></pre>

<p>languageDef =
   emptyDef { Token.commentStart    = &ldquo;/*&rdquo;</p>

<pre><code>        , Token.commentEnd      = "*/"
        , Token.commentLine     = "#"
        , Token.identStart      = letter
        , Token.identLetter     = alphaNum
        , Token.reservedNames   = [ "if"
                                  , "then"
                                  , "else"
                                  , "true"
                                  , "false"
                                  , "not"
                                  , "and"
                                  , "or"
                                  ]
        , Token.reservedOpNames = ["+", "-", "*", "/", "&lt;-"
                                  , "&lt;", "&gt;", "and", "or", "not"
                                  ]
        }
</code></pre>

<p>lexer = Token.makeTokenParser languageDef</p>

<p>identifier = Token.identifier lexer &mdash; parses an identifier
reserved   = Token.reserved   lexer &mdash; parses a reserved name
reservedOp = Token.reservedOp lexer &mdash; parses an operator
parens     = Token.parens     lexer &mdash; parses surrounding parenthesis:
integer    = Token.integer    lexer &mdash; parses an integer
semi       = Token.semi       lexer &mdash; parses a semicolon
whiteSpace = Token.whiteSpace lexer &mdash; parses whitespace</p>

<p>whileParser :: Parser Stmt
whileParser = whiteSpace >> statement</p>

<p>statement :: Parser Stmt
statement =   parens statement</p>

<pre><code>       &lt;|&gt; sequenceOfStmt
</code></pre>

<p>sequenceOfStmt =
   do list &lt;&ndash; (sepBy1 statement' semi)</p>

<pre><code>  return $ if length list == 1 then head list else Seq list
</code></pre>

<p>statement' :: Parser Stmt
statement' =   ifStmt</p>

<pre><code>        &lt;|&gt; assignStmt
        &lt;|&gt; identName            
</code></pre>

<p>ifStmt :: Parser Stmt
ifStmt =
   do reserved &ldquo;if&rdquo;</p>

<pre><code>  cond  &lt;- bExpression
  reserved "then"
  stmt1 &lt;- statement
  reserved "else"
  stmt2 &lt;- statement
  return $ If cond stmt1 stmt2
</code></pre>

<p>identName :: Parser Stmt
identName =
   do  varName &lt;&ndash; identifier</p>

<pre><code>   return $ Ident varName
</code></pre>

<p>assignStmt :: Parser Stmt
assignStmt =
   do var  &lt;&ndash; identifier</p>

<pre><code>  reservedOp "&lt;-"
  expr &lt;- aExpression
  return $ Assign var expr
</code></pre>

<p>aExpression :: Parser AExpr
aExpression = buildExpressionParser aOperators aTerm</p>

<p>bExpression :: Parser BExpr
bExpression = buildExpressionParser bOperators bTerm</p>

<p>aOperators = [ [Prefix (reservedOp &ldquo;&ndash;&rdquo;   >> return (Neg             ))          ]</p>

<pre><code>          , [Infix  (reservedOp "*"   &gt;&gt; return (ABinary Multiply)) AssocLeft]
          , [Infix  (reservedOp "/"   &gt;&gt; return (ABinary Divide  )) AssocLeft]
          , [Infix  (reservedOp "+"   &gt;&gt; return (ABinary Add     )) AssocLeft]
          , [Infix  (reservedOp "-"   &gt;&gt; return (ABinary Subtract)) AssocLeft]
           ]
</code></pre>

<p>bOperators = [ [Prefix (reservedOp &ldquo;not&rdquo; >> return (Not             ))          ]</p>

<pre><code>          , [Infix  (reservedOp "and" &gt;&gt; return (BBinary And     )) AssocLeft]
          , [Infix  (reservedOp "or"  &gt;&gt; return (BBinary Or      )) AssocLeft]
          ]
</code></pre>

<p>aTerm =  parens aExpression</p>

<pre><code>  &lt;|&gt; liftM Var identifier
  &lt;|&gt; liftM IntConst integer
</code></pre>

<p>bTerm =  parens bExpression</p>

<pre><code>  &lt;|&gt; (reserved "true"  &gt;&gt; return (BoolConst True ))
  &lt;|&gt; (reserved "false" &gt;&gt; return (BoolConst False))
  &lt;|&gt; rExpression
</code></pre>

<p>rExpression =
   do a1 &lt;&ndash; aExpression</p>

<pre><code>  op &lt;- relation
  a2 &lt;- aExpression
  return $ RBinary op a1 a2
</code></pre>

<p>relation =   (reservedOp &ldquo;>&rdquo; >> return Greater)</p>

<pre><code>      &lt;|&gt; (reservedOp "&lt;" &gt;&gt; return Less)
</code></pre>

<p>parseString :: String &ndash;> Stmt
parseString str =
   case parse whileParser &ldquo;&rdquo; str of</p>

<pre><code> Left e  -&gt; error $ show e
 Right r -&gt; r
</code></pre>

<p>parseFile :: String &ndash;> IO Stmt
parseFile file =
   do program  &lt;&ndash; readFile file</p>

<pre><code>  case parse whileParser "" program of
    Left e  -&gt; print e &gt;&gt; fail "parse error"
    Right r -&gt; return r
</code></pre>

<p>main = do
  args &lt;&ndash; getArgs
  ast &lt;&ndash; parseFile(head args)
  putStrLn $ show ast
```</p>

<p>But it works&hellip; we can parse. Now i have to make it more production ready and less unstable ;]. This is first attempt at this idea.  I need to expand grammar and think about it more then just few minutes. but i think it is a good start. Next step for me is to make better grammar and parser and move to building interpreter of this mini language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pong tests are wrong]]></title>
    <link href="http://no-fucking-idea.com/blog/2012/06/07/pong-tests-are-wrong/"/>
    <updated>2012-06-07T19:09:00+01:00</updated>
    <id>http://no-fucking-idea.com/blog/2012/06/07/pong-tests-are-wrong</id>
    <content type="html"><![CDATA[<p>After short talk with tomash and his gist <a href="https://gist.github.com/2871286">https://gist.github.com/2871286</a> with performance of vibe.d i decided to write this post.
In my opinion pong tests are wrong and do not show real &ldquo;performance&rdquo;. I said to him to check sinatra with thin handler not webrick and that showed ~1.6k req/sec which is not bad at all. While at my box it was ~900 req/sec so significantly less (Macbook Pro i5).</p>

<p>From this gist we can see that his vibe.d benchmark set pong test at 8425.85 req/sec (He used ab and i used httperf).</p>

<h1>Warp</h1>

<p>My first candidate in this competition of pong tests is haskell warp handler.</p>

<p>code:</p>

<p>``` haskell pingpong.hs</p>

<p>{&ndash;# LANGUAGE OverloadedStrings #&ndash;}</p>

<p>import Network.Wai
import Network.Wai.Handler.Warp
import Network.HTTP.Types (status200)
import Blaze.ByteString.Builder (copyByteString)
import qualified Data.ByteString.UTF8 as BU
import Data.Monoid
import Data.Enumerator (run_, enumList, ($$))</p>

<p>main = do</p>

<pre><code>let port = 8000
putStrLn $ "Listening on port " ++ show port
run port app
</code></pre>

<p>app req = return $</p>

<pre><code>case pathInfo req of
    ["pong"] -&gt; pong
    x -&gt; index x
</code></pre>

<p>pong = ResponseBuilder status200 [ (&ldquo;Content-Type&rdquo;, &ldquo;text/plain&rdquo;) ] $ mconcat $ map copyByteString</p>

<pre><code>[ "pong" ]
</code></pre>

<p>index x = ResponseBuilder status200 [(&ldquo;Content-Type&rdquo;, &ldquo;text/html&rdquo;)] $ mconcat $ map copyByteString</p>

<pre><code>[ "&lt;p&gt;Hello from ", BU.fromString $ show x, "!&lt;/p&gt;"
, "&lt;p&gt;&lt;a href='http://no-fucking-idea.com/pong'&gt;pong&lt;/a&gt;&lt;/p&gt;\n" ]
</code></pre>

<p>```</p>

<p>it is semi rack like syntax ;)</p>

<h1>Benchmark results</h1>

<p>I prepared results to show how big lie is pong test. Because in this type of test / showoff all you test is how fast really you can accept connections. Single thread will always win :). But lets look at results:</p>

<ul>
<li>Multi threaded &ndash; 50 threads   &ndash; Request rate: 858.8 req/s (1.2 ms/req) BOOO!!!!</li>
<li>Multi threaded &ndash; 4 threads ( on for each core ) &ndash; Request rate: 10020.8 req/s (0.1 ms/req) Vibe.d die!!! Yeah!!!!</li>
<li>Single threaded &ndash; default compilation  &ndash; Request rate: 13584.1 req/s (0.1 ms/req) Mother of God!</li>
</ul>


<p>Tested with <code>httperf --uri=/ --port=8000 --num-calls=10000 --num-conns=20</code> httperf command.</p>

<h1>Summary</h1>

<p>You can test it on your own, i did it on latest 7.4.1 Ghc from haskell platform on OSX 10.7. And post reply with your results :) maybe i missed something. Code, scripts to build and run are in repository <a href="https://github.com/JakubOboza/haskell-warp-pong-test">https://github.com/JakubOboza/haskell-warp-pong-test</a>.</p>

<h2>So how to test ?!</h2>

<p>I think you should test your application in default environment so with db behind it, but anyone in this scenario can say it is testing performance of db. But everyday&hellip; users are really testing performance of our db ;>&hellip; or the weakest of the elements in chain. So if your db / rendering engine is performing at level of 50 req / sec fast app handler will not turn it into 5000 req / sec.</p>
]]></content>
  </entry>
  
</feed>
